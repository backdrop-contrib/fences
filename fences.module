<?php
/**
 * @file
 * Fences is a module providing configurable field wrappers.
 */


/**
 * Implements hook_form_alter()
 */
function fences_form_field_ui_field_edit_form_alter(&$form, &$form_state, $form_id){
  $bundle = $form_state['build_info']['args'][0]['bundle'];
  $field_name = $form_state['build_info']['args'][0]['field_name'];

  $suggestion = fences_get_suggestion($bundle, $field_name);

  // Get the list of suggestions.
  $fences = fences_get_fences_suggestion_info();
  foreach (array_keys($fences['field']) as $key) {
    $options[$key] = $fences['field'][$key]['label'];
  }

  $form['instance']['fences_wrapper'] = array(
    '#type' => 'select',
    '#title' => t('Wrapper markup'),
    '#default_value' => $suggestion ? $suggestion : 'div',
    '#options' => $options,
    '#description' => t('Choose the HTML to use to wrap the field.'),
  );
  $form['#submit'][] = 'fences_form_submit';
}

/**
 * Implements hook_form_submit()
 */
function fences_form_submit(&$form, &$form_state) {
  $bundle = $form_state['build_info']['args'][0]['bundle'];
  $fid = $form_state['build_info']['args'][0]['field_id'];
  $field_name = $form_state['build_info']['args'][0]['field_name'];
  $suggestion = $form_state['input']['instance']['fences_wrapper'];

  fences_update_fence_configuration($bundle, $fid, $field_name, $suggestion);
}

/**
 * Function to return the wrapper suggestion if it exists.
 */
function fences_get_suggestion($bundle, $field_name) {
  // On any page load, we are likely to have several fields, so we retrieve and
  // cache all field suggestions.
  $fences = &drupal_static(__FUNCTION__);
  if (is_null($fences)) {
    $fences = array();
    $result = db_query('SELECT bundle, field_name, suggestion FROM {fences}');
    foreach ($result as $row) {
      $fences[$row->bundle][$row->field_name] = $row->suggestion;
    }
  }
  return isset($fences[$bundle][$field_name]) ? $fences[$bundle][$field_name] : NULL;
}

/**
 * Function to update the fences database table.
 */
function fences_update_fence_configuration($bundle, $fid, $field_name, $suggestion) {
  $fence = array(
    'bundle'        => $bundle,
    'machine_name'  => $bundle . '_' . $field_name,
    'fid'           => $fid,
    'field_name'    => $field_name,
    'suggestion'    => $suggestion,
  );

  $suggestion = fences_get_suggestion($bundle, $field_name);

  if ($suggestion) {
    db_update('fences')
      ->fields($fence)
      ->condition('machine_name', $fence['machine_name'])
      ->execute();
  }
  else {
    $wid = db_insert('fences')
      ->fields($fence)
      ->execute();
  }

}

/**
 * Alter the views field item form to change some of the default values.
 * @todo: Make this actually work. Currently cannot change the value from
 * the default value.
 */
function fences_form_views_ui_config_item_form_alter(&$form, &$form_state, $form_id) {
  // Disable the label option
  $form['options']['custom_label']['#default_value'] = FALSE;

  // Set the field settings to use the field_api for rendering.
  $form['options']['field_api_classes']['#default_value'] = TRUE;

  // Disable the default element classes
  $form['options']['element_default_classes']['#default_value'] = FALSE;

  // Enable the element_wrapper style to be none
  $form['options']['element_wrapper_type_enable']['#default_value'] = TRUE;
  $form['options']['element_wrapper_type']['#default_value'] = 0;

  // Enable the element_type style to be none
  $form['options']['element_type_enable']['#default_value'] = TRUE;
  $form['options']['element_type']['#default_value'] = 0;
}

/**
 * @todo: Make this actually work. Currently cannot change the value from
 * the default value.
 */
function fences_form_views_ui_edit_display_form_alter(&$form, &$form_state, $form_id) {
  $form['options']['row_options']['default_field_elements']['#default_value'] = 0;
}

/**
 * Implements hook_preprocess_field()
 */
function fences_preprocess_field(&$vars) {
  $bundle = $vars['element']['#bundle'];
  $field_name = $vars['element']['#field_name'];
  $suggestion = fences_get_suggestion($bundle, $field_name);
  if ($suggestion) {
    // $theme_suggestions[0] = 'field__fences_' . $suggestion;
    // foreach ($vars['theme_hook_suggestions'] as $key => $value) {
    //   $theme_suggestions[$key+1] = $value;
    // }
    // $vars['theme_hook_suggestions'] = $theme_suggestions;
    // or maybe it just needs:
    array_unshift($vars['theme_hook_suggestions'],'field__fences_' . $suggestion);
    // $theme = theme('field__fences_small', $vars);
    // dpm($vars);
    // dpm($theme);
  }
}

/**
 * Implements hook_module_implements_alter().
 */
function fences_module_implements_alter(&$implementations, $hook) {
  if ($hook == 'theme') {
    // Make fences' hook_theme() run last.
    $group = $implementations['fences'];
    unset($implementations['fences']);
    $implementations['fences'] = $group;
  }
}

/**
 * Implements hook_theme().
 */
function fences_theme($existing, $type, $theme, $path) {
  $hooks = array();

  $fences = fences_get_fences_suggestion_info();

  $supported_hooks = array('field');
  foreach ($supported_hooks as $hook) {
    foreach ($fences[$hook] as $suggestion => $data) {
      // Manually register the suggestions for a module, but let hook_theme
      // auto-discover theme-owned suggestions as it normally does.
      if ($fences[$hook][$suggestion]['type'] == 'module') {
        $hook_suggestion = $hook . '__fences_' . str_replace('-', '_', $suggestion);
        foreach (array($hook_suggestion, $hook_suggestion . '-multiple') as $name) {
          $hooks[$name] = array(
            'base hook'      => $hook,
            'render element' => $existing[$hook]['render element'],
            'type'           => $fences[$hook][$suggestion]['type'],
            'theme path'     => $existing[$hook]['theme path'],
            'template'       => str_replace('_', '-', $name),
            'path'           => $fences[$hook][$suggestion]['path'],
          );
        }
      }
    }
  }

  return $hooks;
}

/**
 * Retrieve the hook_fences_suggestion_info data.
 */
function fences_get_fences_suggestion_info() {
  $fences = &drupal_static(__FUNCTION__);

  if (is_null($fences)) {
    $files = array();

    // Call hook_fences_suggestion_info for modules. We need to search each
    // module for template files to get their paths, so we can't use
    // module_invoke_all().
    foreach (module_implements('fences_suggestion_info') as $module) {
      $function = $module . '_fences_suggestion_info';
      if (function_exists($function)) {
        $result = $function();
        if (isset($result) && is_array($result)) {
          // Search the module for template files.
          $files[$module] = drupal_system_listing('/\-\-fences\-.*\.tpl\.php$/', drupal_get_path('module', $module), 'name', 0);
          // Go through each of the results of hook_fences_suggestion_info().
          foreach (array_keys($result) as $hook) {
            foreach (array_keys($result[$hook]) as $suggestion) {
              $template = str_replace('_', '-', $hook . '--fences-' . $suggestion) . '.tpl';
              // Only record the suggestion if a corresponding template file is found.
              if (isset($files[$module][$template])) {
                $fences[$hook][$suggestion] = $result[$hook][$suggestion];
                // We need the path and project type for hook_theme().
                $fences[$hook][$suggestion]['path'] = dirname($files[$module][$template]->uri);
                $fences[$hook][$suggestion]['type'] = 'module';
              }
            }
          }
        }
      }
    }

    // Create a list of the default theme and its base themes.
    $theme_default = $GLOBALS['conf']['theme_default'];
    // We can't use list_themes() here because of #761608.
    $theme_data = _system_rebuild_theme_data();
    foreach (array_keys($theme_data[$theme_default]->base_themes) as $base_theme) {
      $themes[$base_theme] = 'base_theme_engine';
    }
    $themes[$theme_default] = 'theme_engine';
    // Include the template.php files of the entire theme stack.
    foreach (array_keys($themes) as $theme) {
      include_once './' . drupal_get_path('theme', $theme) . '/template.php';
    }

    // Call hook_fences_suggestion_info for themes.
    foreach ($themes as $theme => $type) {
      // Search the theme for template files.
      $files[$theme] = drupal_system_listing('/\-\-fences\-.*\.tpl\.php$/', drupal_get_path('theme', $theme), 'name', 0);
      $function = $theme . '_fences_suggestion_info';
      if (function_exists($function)) {
        $result = $function();
        if (isset($result) && is_array($result)) {
          // Go through each of the results of hook_fences_suggestion_info().
          foreach (array_keys($result) as $hook) {
            foreach (array_keys($result[$hook]) as $suggestion) {
              $template = str_replace('_', '-', $hook . '--fences-' . $suggestion) . '.tpl';
              // Only record the suggestion if a corresponding template file is found.
              if (isset($files[$theme][$template])) {
                $fences[$hook][$suggestion] = $result[$hook][$suggestion];
                // We need the project type in hook_theme().
                $fences[$hook][$suggestion]['type'] = $type;
              }
            }
          }
        }
      }
      // If hook_fences_suggestion_info() doesn't exist for the theme, do a
      // "lazy" hook implementation by parsing the file names of matching
      // template files.
      else {
        foreach ($files[$theme] as $template => $data) {
          list($hook, $suggestion) = explode('--', $template);
          $suggestion = str_replace(array('fences-', '-multiple', '.tpl'), '', $suggestion);
          if (!isset($fences[$hook][$suggestion])) {
            $fences[$hook][$suggestion] = array(
              'label'       => $suggestion,
              'description' => t('A <@tag> tag', array('@tag' => $suggestion)),
              'type'        => $type,
            );
          }
        }
      }
    }

    // Sort the tags.
    foreach (array_keys($fences) as $hook) {
      $none = $fences[$hook]['none'];
      unset($fences[$hook]['none']);
      ksort($fences[$hook]);
      $fences[$hook] = array('none' => $none) + $fences[$hook];
    }

    // Allow modules and themes to alter the fences info.
    drupal_alter('fences_suggestion_info', $fences);
  }
  return $fences;
}

/**
 * Implements hook_fences_suggestion_info().
 */
function fences_fences_suggestion_info() {
  // Suggestions for the "field" theme hook.
  $fences['field'] = array(
    'none' => array(
      'label' => t('No markup'),
      'description' => t('No wrapping HTML'),
    ),
    'address' => array(
      'label' => t('address'),
      'description' => t('An <address> tag'),
    ),
    'div' => array(
      'label' => t('div'),
      'description' => t('A semantically generic <div> tag. Should only be used as a last resort.'),
    ),
    'figure' => array(
      'label' => t('figure'),
      'description' => t('A <figure> tag'),
    ),
    'pre' => array(
      'label' => t('pre'),
      'description' => t('A <pre> tag'),
    ),
    'precode' => array(
      'label' => t('pre code'),
      'description' => t('A <pre> tag and a <code> tag wrapper'),
    ),
    'small' => array(
      'label' => t('small'),
      'description' => t('A <small> tag'),
    ),
  );
  return $fences;
}
